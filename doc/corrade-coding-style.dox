/*
    This file is part of Corrade.

    Copyright © 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016,
                2017 Vladimír Vondruš <mosra@centrum.cz>

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

namespace Corrade {
/** @page corrade-coding-style Coding style
@brief Coding style and best practices to preserve maintainability and
consistent style across whole project.

@tableofcontents

Please note that if you have a good excuse to either break the rules or modify
them, feel free to do it (and update this guide accordingly, if appropriate).
Nothing is worse than rule that hurts productivity instead of improving it.

You can also take inspiration from other thoroughly written coding style
guidelines of large projects:

 - LLVM: http://llvm.org/docs/CodingStandards.html
 - Qt: http://qt-project.org/wiki/Qt_Coding_Style
 - Chromium: http://dev.chromium.org/developers/coding-style/cpp-dos-and-donts

@section corrade-coding-style-text Text files in general

Each file must have one blank line at the end (Git will warn you in the
diff if it's not the case), indentation is done exclusively with spaces (4
spaces). Trailing whitespaces are not permitted (and you should set up your
Git installation to warn about that). Files in the repository should be with LF
line ending by default. If CR+LF line endings are required for particular
files, they have to be explicitly listed in `.gitattributes` file.

Logic sections of the code and documentation paragraphs are always separated
with not more than one empty line to save vertical space. Sentences are always
separated with only one space.

The text (and code) should be wrapped around 80th column to make it possible to
view more files alongside each other without breaking their layout, long
single-line statements are allowed unless it hurts readability.

@section corrade-coding-style-cmake CMake code

All CMake functions and macros (e.g. @cmake add_executable() @ce,
@cmake set() @ce) are lowercase, keywords (e.g. `FILES`, `DESTINATION`)
are uppercase. Variables are mostly uppercase with underscores between words,
except for variables with direct relation to any named target --- then they
have the target name as prefix with no case change, followed with underscore,
the rest of variable name is uppercase, e.g. variable holding all sources for
target `CorradePluginManager` will be named `CorradePluginManager_SRCS`.

Multi-line calls (i.e. @cmake set() @ce) have trailing parenthesis on the
same line as last parameter, *not* on separate line:

@code{.cmake}
set(CorradeUtility_SRCS
    Configuration.cpp
    CpnfigurationGroup.cpp
    Directory.cpp)
@endcode

Source and header lists should be ordered alphabetically, subdirectories last,
preferably separated by a single empty line.

Prefer to use the new, non-global CMake workflow, so
@cmake target_include_directories() @ce,
@cmake target_compile_definitions() @ce and
@cmake target_compile_options() @ce instead of
@cmake include_directories() @ce, @cmake add_definitions() @ce and
modifying the global `CMAKE_CXX_FLAGS`.

@section corrade-coding-style-cpp C++ code

@subsection corrade-coding-style-cpp-filesystem File and directory naming

All C++ header and source files are named after the class they contain with no
case change. Thus there should be only one class per file, but if the classes
are closely related and not very large, you can make an exception (see
@ref Corrade/Utility/Debug.h or @ref Corrade/Utility/TypeTraits.h for example).
That might also help with compilation times.

Supporting headers (not relevant to end user), such as various `configure.h`,
`visibility.h` etc., which are used only internally and don't contain any
publicly documented APIs should have first letter of the name lowercased to
distinguish them from API headers.

Code in the root Corrade namespace is in `src/Corrade` directory, each
subnamespace is in its own subdirectory. Unit tests are in `Test` subnamespace
(and subdirectory). Implementation details (helper classes etc.) which
shouldn't be visible to end users should be in `Implementation` subnamespace in
the same file as the class/function for which the implementation is.

Implementation details which are not referenced from any header should be
either in anonymous namespace in source file
(@ref corrade-coding-style-cpp-anonymous-namespace "see below") or (if
referenced from more than one source file, from tests etc.) in `Implementation`
namespace in separate file in `Implementation` subdirectory. These
subdirectories are treated as private implementation, thus they are by default
excluded from documentation, their symbols shouldn't be exported and contents
of these subdirectories shouldn't be installed anywhere.

@subsection corrade-coding-style-cpp-files File structure

Headers have an strict structure. Include guards are basically include path
with slashes replaced with underscores to make refactoring as easy as possible.
Directly after them is license block, blank line, then Doxygen file
documentation block, blank line and after that the contents of the header.
Include guard ending is only @cpp #endif @ce, without any additional comments.

Source file have similar structure as headers - first license block, then
blank line, then the includes, then blank line, then contents of the file.

Includes should be organized into separate groups separated with blank line -
first header belonging to the particular source file (if the file is source
file), then system includes, then includes from the engine itself and then
internal includes used only in the particular file (e.g. `configure.h`).
Inter-project includes should be relative to the `src/` directory. Includes
from system libraries and dependencies are in angle brackets, includes from the
library itself are in quotes. Includes should be sorted by "level" (e.g. C
includes (`&lt;cstdlib&gt;`) before C++ includes (`&lt;string&gt;`) and those
before dependencies (`&lt;dirent.h&gt;`)), then by path name.

@subsection corrade-coding-style-cpp-format Code format

@subsubsection corrade-coding-style-cpp-naming Naming

Namespaces, classes and structs, enums, type template names and static
constants should be named with `CamelCase`, i.e. first letter of the name and
each successive word uppercase, other lowercase. E.g. `ConfigurationGroup`.
Classes with pure virtual methods or base classes which are not meant to be
used directly should be prefixed with `Abstract`.

Functions, function parameters, non-type template names and variables should
be named with `camelCase`, i.e. first letter of the name lowercase, each
successive word starting with uppercase. E.g. `trimLeadingSpaces()`.

Preprocessor macros should be written in uppercase with underscores between
words, e.g. `CORRADE_EXPORT` and prefixed with project name. Exceptions are
tiny one-short macros that are undefined right after they are used (switch case
helpers etc.), in that case they are lowercase and prefixed with underscore.

Redundant information and abbrevations in names are not recommended (use
`determinant`, `inverse` and `attribute` instead of `det`, `inv` and `attr`).
Hungarian notation, `I` and `E` prefixes for interfaces and enums are
forbidden and cruelly punished, if found. Acronyms should be written with
first letter uppercase only to avoid visual collision with preprocessor macros
(`Http` and `Sha1` instead of `HTTP` and `SHA1`).

Private variables clashing with (mostly getter) function names can have
one underscore before them, don't use two underscores, as they are reserved
for internal usage by the C++ standard. Underscores before the name shouldn't
be used in public API or function parameters, as it looks ugly in the
documentation.

@subsubsection corrade-coding-style-cpp-forward-declarations Forward declarations and forward declaration headers

Use forward declarations in headers as much as possible, as it can significantly
reduce time of compilation. If forward declarations are overly complex, consider
adding forward declaration header containing all of them to save users' time.

@subsubsection corrade-coding-style-cpp-namespace Namespace declarations

Namespace declaration is on one line, separated with blank lines on both
sides. The code inside the declaration is not indented to save horizontal
space.

@code{.cpp}
namespace Corrade { namespace Utility { namespace Test {

// ...

}}}
@endcode

The only exception is with forward declarations: use indentation where it
improves readability, e.g.:

@code{.cpp}
namespace Corrade { namespace Utility {
    class Configuration;
}}
@endcode

@code{.cpp}
namespace Corrade {

namespace TestSuite {
    class Tester;

    namespace Compare {
        class FileContents;
    }
}

// the actual code...

}
@endcode

@subsubsection corrade-coding-style-cpp-classes Class and structure declarations

Class and structure protection levels are ordered as following: first friend
declarations, then public members, then protected members and finally private
members, so class public interface is easy to spot at the top of the file.

Members are ordered as following: first classes and enums, then static
functions, then non-static functions (where constructors, destructors and
assignment operators are first), then static variables, then non-static
variables. Again, classes and methods are more important for user than
variables, static members are more important than non-static.

@subsubsection corrade-coding-style-cpp-style Blocks, whitespace and indentation

The goal is to preserve readability with minimal amount of wasted vertical
and horizontal space.

Indented is everything except namespace declarations (as specified above) -
blocks, class protection levels, @cpp case @ce statements. Overlong line breaks
are indented also with 4 spaces (or any other value if it makes more sense,
e.g. for aligning similar code).

@code{.cpp}
class Foo {
    public:
        void bar() {
            addMethods(&Foo::methodNameOne,
                       &Foo::methodNameTwo);
        }

    protected:
        void methodNameOne();
        void methodNameTwo();
};
@endcode

Whitespace is *not allowed* inside parentheses and between function name or
branch/loop statement and left parenthesis (or between constructed variable
name and left brace) and before semicolon. It *must be* around block braces
if the block is not empty. It *must not be* space before, but after the
comma.

@code{.cpp}
if ( statement ){foo ( a ,b ) ;} // awful! (_everything_ is misplaced)
if(statement) { foo(a, b); }     // perfect
@endcode

Whitespace *should be* around operators with low precedence (namely `+`, `-`,
`<<`, `>>` but not on unary `-`), around all boolean and comparison operators
(`&&`, `||`, `==`, `!=`, `<`, `<=`, `>=`, `>`), around `=` and related operators
and around ternary operator. Whitespace *shouldn't be* around `/`, `*`, `%` to
indicate they have precedence before addition and subtraction. Whitespace can
or need not to be around binary operators (`&`, `|`, `^`), whichever looks
better in particular content.

@code{.cpp}
a += b*5 - 3*(c != 0 ? 64/c : 1);
@endcode

Block opening braces start on the same line as corresponding statement (class /
function declaration, branch and loop statement), @cpp else @ce and
@cpp else if @ce statements have both braces on the same line too:

@code{.cpp}
if(expression) {
    // ...
} else if(another || expression) {
    // ...
} else {
    // ...
}
@endcode

If the block is only one statement and short enough, it can be on the same line:

@code{.cpp}
void setProcessingDelay(int delay) { processingDelay = delay; }
@endcode

@code{.cpp}
if(!initialized) return false;
@endcode

The only exceptions when opening braces are on the following line is when the
@cpp if @ce statement or constructor initializer list is spanning multiple
lines:

@code{.cpp}
if(a_very_long_expression_spanning_whole_line ||
    another_fairly_lengthy_expression ||
    yet_another_overly_complicated_expression)
{
    // ...
}
@endcode

@code{.cpp}
MyClass::MyClass():
    _oneMember(lengthy_member_initialization),
    _anotherMember(another_fairly_lengthy_expression),
    _thirdMember(more_code)
{
    // ...
}
@endcode

The opening brace should be also on the following line when preprocessor
branching is involved, as specifying it twice may confuse code folding in some
editors:

@code{.cpp}
// Bad
#ifndef CORRADE_TARGET_WINDOWS
if(expression) {
#else
if(worked || around || expression) {
#endif
    // ...
}

// Good
#ifndef CORRADE_TARGET_WINDOWS
if(expression)
#else
if(worked || around || expression)
#endif
{
    // ...
}
@endcode

@subsubsection corrade-coding-style-cpp-switches Switch statements

Switch statements are usually very verbose and thus they are often subject of
various shortening and whitespace tricks. The goal is to make them as readable
as possible without wasting too much vertical space, for example:

@code{.cpp}
switch(type) {
    case Byte:      size = 8;   break;
    case Short:     size = 16;  break;
    case Int:       size = 32;  break;
    case Long:      size = 64;  break;
    case LongLong:  size = 128; break;

    default:        size = 0;
}
@endcode

@subsubsection corrade-coding-style-cpp-keywords Class member and function keywords

Use keywords in this order: @cpp template virtual inline constexpr explicit static @ce.
When the function is fully defined in class body or when it is marked as
@cpp constexpr @ce, don't mark it as @cpp inline @ce, it's redundant. Only base
virtual functions should have @cpp virtual @ce keyword, the reimplementations
should be marked with @cpp override @ce instead.

@subsubsection corrade-coding-style-cpp-macros Preprocessor macros

Preprocessor macros should have the same indentation as surrounding code. Not
indenting or indenting between @cpp # @ce and the macro breaks visual flow and
thus is not allowed. If the macro is long or contains code which should be
spanned or multiple lines, it should be wrapped on multiple lines, each
successive line indented and the line wrapping indicator `\` should be aligned
around 80th column, preferably on some tab-stop.

@subsection corrade-coding-style-cpp-constructors Class constructors and destructors

All constructors (except copy and move constructors) should be @cpp explicit @ce
by default. Remove the keyword only if you want to allow implicit conversions
or want to construct the class with brace initializer (e.g. vector and matrix
classes) If the class has no constructor, add explicit default-created one:

@code{.cpp}
class MyClass {
    public:
        explicit MyClass() = default;

        // ...
};
@endcode

If the constructor is intentionally implicit, mark it with appropriate comment.

If the class has only static members (e.g. various utility classes, traits
classes), delete the constructor to prevent instantiating the class by
mistake:

@code{.cpp}
class UtilityClass {
    public:
        UtilityClass() = delete;

        // ...
};
@endcode

If the class is not meant to be instantiated directly and doesn't have any pure
virtual methods, consider using protected destructor. Only if that is not
possible (because you need to be able to call @cpp delete @ce on the
@cpp Abstract* @ce class), use virtual destructor.

@subsection corrade-coding-style-cpp-constexpr Constant expressions and constants

Use @cpp constexpr @ce keyword where appropriate, mainly for getters, operators
and static pure functions which will be heavily used with compile-time
constants, such as @ref Containers::EnumSet::operator&().

Traits class members and class constants which are not meant to be referenced
or pointed to should be defined as @cpp constexpr @ce function or using
anonymous typed enum (@ref corrade-coding-style-cpp-enums "see below"), because
declaring them as @cpp static const @ce variable will result in another
(probably unwanted) symbol and the constant might not be always inlined.

@subsection corrade-coding-style-cpp-assert Assertions

Use asserts as much as possible. Utility library has convenient @ref CORRADE_ASSERT(),
@ref CORRADE_INTERNAL_ASSERT(), @ref CORRADE_INTERNAL_ASSERT_OUTPUT() and
@ref CORRADE_ASSERT_UNREACHABLE() macros, see their documentation for more
information. When documenting assertions in Doxygen documentation blocks (see
@ref corrade-coding-style-documentation "below", use the word "expects" to
describe a condition that is covered by an assert macro).

@subsection corrade-coding-style-cpp-enum-inheritance Enums and inheritance

Try to avoid having one enum accessible through more than one type, for
example:

@code{.cpp}
class AbstractImage {
    public:
        enum class Format { RGB, RGBA };

        void setFormat(Format);
};
class Image2D: public AbstractImage {};
class ImageWrapper: public AbstractImage {};
@endcode

With this you have more than one way to specify the format (trivial choices
slowing down the development), not to mention confusion (are all the enums the
same or is each enum different?) and weird combinations:

@code{.cpp}
Image2D image;
image.setFormat(AbstractImage::Format::RGB); // should I prefer `AbstractImage`
image.setFormat(Image2D::Format::RGB);       // or `Image2D`?
image.setFormat(ImageWrapper::Format::RGBA); // is this even allowed?
@endcode

Better way would be to extract the enum out, now there is only one way to
specify the format (and it's less typing). Also, when the user later decides to
change the image type to another, the enum value doesn't need to be updated:

@code{.cpp}
enum class PixelFormat { RGB, RGBA };

class AbstractImage {
    public:
        void setFormat(PPixelFormat);
};
class Image2D: public AbstractImage {};
class ImageWrapper: public AbstractImage {};

Image2D image;
image.setFormat(PixelFormat::RGBA);
@endcode

On the other hand, if each class has its own enum values, the original way is
the preferred one:

@code{.cpp}
class ColoredImage {
    public:
        enum class Format { RGB, RGBA };
};
class BWImage {
    public:
        enum class Format { Grayscale, Binary };
};
@endcode

@see @ref corrade-coding-style-cpp-enums

@subsection corrade-coding-style-cpp-pointers Naked pointers

Prefer to use references instead of pointers in function parameters and class
members. Use raw pointers only as non-owning optional references, use
@ref Containers::ArrayView and @ref Containers::StaticArrayView to pass array
references around. If you need to hold or transfer ownership, use
@ref std::unique_ptr or @ref Containers::Array. If you need given class to be
copyable/movable, use @ref std::reference_wrapper instead of a reference.

Avoid to use @ref std::shared_ptr, if possible. Unlike @ref std::unique_ptr and
@ref Containers::Array, which are just zero-cost wrappers checked at
compile-time, shared pointers have serious runtime penalty due to reference
counting.

@subsection corrade-coding-style-cpp-forbidden Forbidden and deprecated C/C++ features

Don't use RTTI (@cpp dynamic_cast @ce and @ref std::type_info) and exceptions,
if you don't desperately need to. They violate C++ principle of "don't pay for
what you don't use". Ideally the code should be compilable with
`-fno-rtti -fno-exceptions`.

@subsubsection corrade-coding-style-cpp-heavy-headers Heavy STL headers

Don't add heavy STL includes in header files. Each of these
@cpp #include @ce s brings >20k lines of source code which needs to be
preprocessed and compiled even if majority of it is later tossed out. Prefer to
include these only in source files. The following headers are the heaviest,
numbers taken from @cb{.sh} g++-4.8 -std=c++11 -E | wc -l @ce:

-   `<algorithm>` --- 46k lines after preprocessing. Most of it are new
    C++11 features, with C++03 it had only ~10k.
-   `<istream>` and friends --- 22-24k lines after preprocessing. Use `<iosfwd>`
    instead and include stream headers only in source files. If you want to
    just print something to output, use Utility::Debug class and friends.
-   `<iterator>` --- includes stream headers, thus the same as above.
-   `<memory>` --- 25k lines after preprocessing.
-   `<random>` --- 36k lines after preprocessing.

Some other headers (e.g. the container ones) are heavy too, but in most cases
they just need to be included.

@subsubsection corrade-coding-style-cpp-using using namespace keyword

@cpp using namespace std @ce is not allowed. It brings many symbols into
default namespace and can lead to unintended behavior. Consider `abs()`
function. If using it without `std::` prefix, you can by mistake use the
non-overloaded `double abs(double)` from plain C `<math.h>` header, which can
cause serious performance issues when using it for integers only. By explicitly
calling `std::abs()` you ensure that proper overload is always selected.

@cpp using namespace @ce keyword should be used only for root namespace, i.e.
@cpp using namespace Corrade @ce and not @cpp using namespace Corrade::Utility @ce.
If you are using some class from subnamespace in many places, use only that
particular name, e.g. @cpp using Corrade::Utility::ConfigurationGroup @ce and
try to restrict it to as small block of code as possible (e.g. place the
@cpp using @ce only in function body).

It's probably common practice, but repeating won't hurt: headers shouldn't
have @cpp using @ce declarations at all (unless there is good excuse for
bringing some useful feature from different namespace into another namespace ---
but not in the default namespace!).

@subsubsection corrade-coding-style-cpp-backward C-style casts

Don't use C-style casts, use C++-style @cpp static_cast @ce and
@cpp reinterpret_cast @ce instead. Corrade enables compiler warning about their
usage in `CORRADE_CXX_FLAGS` CMake variable. You can also use "constructor
cast" instead of @cpp static_cast @ce when doing non-harmful conversions, such
as integer to float or strongly-typed enum to its underlying type.

@code{.cpp}
int a = 22;
int b = 7;
float pi = ((float) a)/b;           // bad!
float pi = static_cast<float>(a)/b; // good
float pi = float(a)/b;              // even better here
@endcode

@subsubsection corrade-coding-style-cpp-enums Unscoped and untyped enums

Prefer to use C++11 @cpp enum class @ce. Use @ref Containers::EnumSet instead
of integral bit masks. Always explicitly specify underlying type, it might save
some memory and also allows for forward declaration of the enum, which is good
if the enum is part of otherwise large header.

@see @ref corrade-coding-style-cpp-enum-inheritance

@subsubsection corrade-coding-style-cpp-anonymous-namespace static keyword

Prefer to use anonymous namespaces instead of @cpp static @ce keyword.
Anonymous namespace ensures that the symbols won't be exported and unlike
@cpp static @ce keyword it can be used also for type declarations.

@section corrade-coding-style-comments Comments

All comments should be in C-style (i.e. slash and asterisk, not two slashes).
There should always be space after leading asterisk and before trailing
asterisk, this is also the case for C++-style comments, if are used somewhere
(mostly in the documentation, because nesting of C-style comments is
impossible).

Multi-line comments should be done in a way which preserves block align (so
when first line starts with slash, asterisk and space, the second line should
be indented with three spaces to align the text).

@include codingstyle/comments.h.nostrip

@section corrade-coding-style-documentation Doxygen documentation

Doxygen documentation uses C-style comments with two asterisks, each
successive line should start with asterisk and space. However, documentation
block starting at beginning of the line (with no indentation) and spanning
more lines shouldn't have leading asterisks and use whole 80 column width to
save horizontal space.

@include codingstyle/doxygen.h.nostrip

Doxygen commands are prefixed with `@`, not `\`.

If the documentation comment is short enough, it can be on one line. If not,
the first line should contain only the slash and two asterisks. However, there
are exceptions for commands that can be on the first line of the multiline
documentation block - namely @c \@page, @c \@name, @c \@file, @c \@namespace
and other commands for "out-of-place" documentation.

Doxygen documentation is mainly in header files. In source file should be only
@c \@todo or @c \@bug items related to particular lines of code. Sections inside
class/function documentation should be prefixed with corresponding name (with no
case change), followed by dash, the rest of the name is in lowercase with dashes
between words:

@include codingstyle/doxygen-sections.h.nostrip

Additional documentation files which don't belong to any particular class
(e.g. namespaces, overview...) are in `doc/` directory and use `*.dox`
extension. Documentation pages, page sections and documentation files should be
named in lowercase with dashes between words, e.g. `corrade-coding-style`,
filename corresponds to name of documentation page it contains.

Each file has a file documentation block (@c \@file) which right after license
block. It explains only in @c \@brief what content given header contains so the
user is able to go to given type documentation right from the file list:

@include codingstyle/doxygen-file.h.nostrip

Namespace documentation is only in the `namespaces.dox` file inside `doc/`
directory. Exception is in case given namespace appears only in one file, is
tightly tied to some class or function and does not make sense outside of it.
In that case the documentation should be directly in the file.

Class, function and enum documentation block always starts with an @c \@brief
description, which is on a single line and doesn't end with a period. Doxygen's
"autobrief" functionality has various drawbacks, bugs and limitations because
and thus @c \@brief should be used explicitly. After that is documentation of
template parameters, function parameters and return value. These are documented
only if it's not obvious from the description or function/parameter name (i.e.
it's not needed for getters and setters). If needed, follows an empty line and
paragraphs of longer description, not prefixed with @c \@note or anything
(these are used only to further highlight content inside those paragraphs).
Last are various @c \@see, @c \@todo sections and other special commands.

It is often the case that you already have some indentation from the left side
and you need to fit the documentation into quite a narrow block. Try to use the
available horizontal space to the maximum, so indent only as strictly necessary
and don't be afraid to make exceptions for overly long identifiers that would
otherwise cause excessive blank space. Example:

@include codingstyle/doxygen-function.h.nostrip

Trivial function overloads (e.g. `const` overloads) are marked only with
@c \@overload keyword and are always *after* the original documented function:

@include codingstyle/doxygen-overload.h.nostrip

Enum value and trivial C structure documentation is without the @c \@brief
section because it only adds unnecessary padding and the brief section does not
have any other visual difference.

If the documentation is short enough, it can be placed after the documented
element, but only if it doesn't exceed the 80 character limit too much (e.g.
enum value documentation):

@include codingstyle/doxygen-short.h.nostrip

For hiding implementation details from documentation or for working around
Doxygen parsing issues (and false positive warnings), preprocessor define
`DOXYGEN_GENERATING_OUTPUT` can be used. It is defined only when Doxygen
generates the documentation. If that works around some Doxygen parsing bug,
don't forget to mark it with @c \@todoc (see below). Example:

@include codingstyle/doxygen-macro.h.nostrip

Code blocks using the `\@``code` command should be separated from surrounding
text with a blank line and every code block should specify the language so
highlighting is done properly:

@include codingstyle/doxygen-code-block.h.nostrip

See @ref corrade-coding-style-documentation-code "below" for a way to highlight
inline code snippets. The inline code is detected using a heuristics and due to
Doxygen XML output limitations, sometimes a single-line code block is detected
as inline code and prepended to the immediately following paragraph. In order
to prevent that, add a stray @cb{.html} <p> @ce tag right after the block:

@include codingstyle/doxygen-code-block-workaround.h.nostrip

@subsection corrade-coding-style-documentation-ordering Section ordering

In detailed documentation the text should be always first, additional blocks
are then ordered by their importance. Various @c \@note, @c \@attention and
@c \@warning blocks to highlight some information are always first, then
@c \@see block with links to related stuff, then various support information
such as @c \@partialsupport, after that @c \@deprecated information and
@c \@todo, @c \@todoc and @c \@bug always last, as they are the least important
and in most cases only for internal use.

@subsection corrade-coding-style-documentation-commands Special documentation commands

@subsubsection corrade-coding-style-documentation-code Code

It's possible to annotate inline code with language as well. There's no
difference in the output for the stock Doxygen HTML output, but third-party
tools can make use of it. The @c \@cb command denotes beginning of inline code
snippet and takes the language as an argument. Inline code end is denoted with
@c \@ce. To make things easier, there are @c \@cpp and @c \@cmake aliases that
expand to <tt>\@cb{.cpp}</tt> and <tt>\@cb{.cmake}</tt>, respectively.

@include codingstyle/doxygen-code-inline.h.nostrip

@subsubsection corrade-coding-style-documentation-commands-todoc Documentation-related TODOs

TODOs about documentation (or about Doxygen workarounds) should be written
with @c \@todoc instead of @c \@todo. They will appear on @ref todoc
"separate page".

@subsubsection corrade-coding-style-documentation-commands-debugoperator Debugging operators

Operators for printing types on Corrade's debug output should be marked with
@c \@debugoperator, e.g.:

@include codingstyle/doxygen-debugoperator.h.nostrip

They will appear as related functions within documentation of class specified
as the parameter and also crossreferenced from page @ref debugoperators.

For non-class enums there is @c \@debugoperatorenum command and for in-class
enums the @c \@debugoperatorclassenum command:

@include codingstyle/doxygen-debugoperatorenum.h.nostrip

Debug operator for non-class enum will appear in documentation of surrounding
namespace, debug operator for class enum will appear as related function in
documentation of given class.

@subsubsection corrade-coding-style-documentation-commands-configurationvalue Configuration value parsers and writers

Helper classes for parsing and writing configuration values should be marked
with @c \@configurationvalue, and referenced from the class using
@c \@configurationvalueref e.g.:

@include codingstyle/doxygen-configurationvalue.h.nostrip

They will appear linked with documentation of class specified as the
parameter and also crossreferenced from page `configurationvalues`.

@subsubsection corrade-coding-style-documentation-commands-partialsupport Partially supported features

Features that are not supported on all platform should be marked with
@c \@partialsupport, listing unsupported platforms and optionally reason why.

@subsubsection corrade-coding-style-documentation-commands-experimental Backwards compatibility and experimental features

Common practice is to keep backwards compatibility when refactoring APIs --- if
given feature is present for a considerable amount of time or is already part
of some release, any change that breaks source compatibility should be
complemented with backwards-compatible function or type alias that is marked as
deprecated using @c \@deprecated and one of @ref CORRADE_DEPRECATED() macros.
If given feature is still in experimental stage, maintaining backwards
compatibility might hurt innovation --- in that case the feature should be
marked with @c \@experimental.

@section corrade-coding-style-git Git commit messages, branch and tag format

Each commit message should have short one-line explanation at the beginning,
formed as a sentence (i.e., first word capitalized and period at the end). If
the commit affects only some submodule (namespace...), module name should be
prepended and separated from the (uncapitalized) rest of the sentence with
colon (and space). Detailed example:

    ModuleName: short one-line summary.

    More detailed explanation text, if necessary, wrapped on multiple lines,
    each line at most ~72 characters long to avoid ugly wrapping in git log.

     - Bullet points, indented with one space before and one space after the
       bullet, indented to have the text aligned. Colons are allowed too, but
       not mixed with bullets.
     - Bullet points are separated from surrounding text with blank lines.

    It is good to use *emphasise*, _underline_ or `code` as in Markdown, if
    necessary, but they shouldn't be overused.

        Multi-line code examples are indented with four spaces, as in Markdown
        syntax.

Branches and tags should be named with lowercase names with words separated
with colons (`-`), e.g. `physics-performance-tweaks`. Version tags start with
`v`, followed by version number, e.g. `v1.0.3`.
*/
}
